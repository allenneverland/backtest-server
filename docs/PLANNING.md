# BacktestServer 專案規劃

## 目錄

- [1. 專案概述](#1-專案概述)
  - [1.1 願景與目標](#11-願景與目標)
  - [1.2 範圍界定](#12-範圍界定)
  - [1.3 主要功能](#13-主要功能)
- [2. 技術架構](#2-技術架構)
  - [2.1 架構概述](#21-架構概述)
  - [2.2 核心技術選型](#22-核心技術選型)
  - [2.3 模組化設計](#23-模組化設計)
  - [2.4 資料流程](#24-資料流程)
- [3. 開發規劃](#3-開發規劃)
  - [3.1 開發階段](#31-開發階段)
  - [3.2 里程碑](#32-里程碑)
  - [3.3 時程安排](#33-時程安排)
  - [3.4 團隊分工](#34-團隊分工)
- [4. 核心模組詳細規劃](#4-核心模組詳細規劃)
  - [4.1 領域類型模組](#41-領域類型模組)
  - [4.2 數據處理模組](#42-數據處理模組)
  - [4.3 策略 DSL 模組](#43-策略-dsl-模組)
  - [4.4 回測引擎模組](#44-回測引擎模組)
  - [4.5 消息系統模組](#45-消息系統模組)
- [5. 資料庫設計](#5-資料庫設計)
  - [5.1 資料庫技術選型](#51-資料庫技術選型)
  - [5.2 主要資料表結構](#52-主要資料表結構)
  - [5.3 查詢優化策略](#53-查詢優化策略)
- [6. 測試策略](#6-測試策略)
  - [6.1 測試類型](#61-測試類型)
  - [6.2 測試自動化](#62-測試自動化)
  - [6.3 效能測試](#63-效能測試)
- [7. 部署與運維](#7-部署與運維)
  - [7.1 部署環境](#71-部署環境)
  - [7.2 監控策略](#72-監控策略)
  - [7.3 備份與恢復](#73-備份與恢復)
- [8. 風險評估與管理](#8-風險評估與管理)
  - [8.1 技術風險](#81-技術風險)
  - [8.2 專案風險](#82-專案風險)
- [9. 擴展性考量](#9-擴展性考量)
  - [9.1 未來功能擴展](#91-未來功能擴展)
  - [9.2 架構擴展性](#92-架構擴展性)

## 1. 專案概述

### 1.1 願景與目標

BacktestServer 是一個使用 Rust 開發的高效能金融回測伺服器，專為支持多策略和動態策略管理設計。專案的主要目標是：

1. **高效能**：利用 Rust 的系統級性能，提供比現有 Python 或 Java 等回測系統更高效的回測處理能力
2. **可擴展性**：支持多種資產類型、交易所和資料頻率，並易於擴展新的功能模組
3. **安全性**：採用隔離沙箱運行策略，防止惡意代碼和資源濫用
4. **彈性策略開發**：提供專用的 YAML 格式 DSL (Domain Specific Language)，簡化策略開發流程
5. **多策略管理**：支持策略版本控制、生命週期管理和績效分析
6. **消息驅動架構**：使用 RabbitMQ 實現可靠的通訊機制，便於與其他系統整合

### 1.2 範圍界定

BacktestServer 專案範圍包括：

- 金融市場數據的導入、清洗、存儲和提供
- 策略 DSL 的解析和執行
- 隔離的策略執行環境
- 訂單模擬和倉位管理
- 風險管理和績效評估
- 回測任務管理和結果分析
- RabbitMQ 消息系統和通訊協議
- 技術指標計算和數據預處理

不在範圍內的功能：

- 圖形化用戶界面（UI）
- 實時交易執行和連接到實際交易所
- 複雜的機器學習模型訓練

### 1.3 主要功能

1. **數據管理**
   - 支援多種金融資產數據格式導入（CSV、數據庫等）
   - 數據驗證和清洗
   - 高效時間序列數據存取和管理
   - 技術指標預計算和緩存

2. **策略開發與管理**
   - 基於 YAML 的策略 DSL
   - 策略版本控制和生命週期管理
   - 策略快照和狀態保存

3. **回測系統**
   - 高效的歷史數據回放
   - 訂單執行模擬和滑點模型
   - 彈性的資金管理和倉位追蹤
   - 風險管理和限制執行

4. **績效分析**
   - 各類量化績效指標計算
   - 回測結果存儲和比較
   - 績效報告生成

5. **消息系統**
   - 基於 RabbitMQ 的消息中間件
   - 多種消息模式（請求/回應、發布/訂閱、工作佇列）
   - 消息認證和授權機制
   - 消息驅動的事件通知

## 2. 技術架構

### 2.1 架構概述

BacktestServer 採用模組化、多層次的系統架構：

1. **資料層**：負責數據的儲存和訪問
   - TimescaleDB 用於時間序列數據
   - Redis 用於快取和事件處理

2. **核心層**：實現主要業務邏輯
   - 數據導入和提供模組
   - 策略 DSL 解析和執行
   - 回測引擎和執行模擬

3. **通訊層**：處理系統間通訊
   - RabbitMQ 消息系統
   - 消息處理器和路由
   - 事件發布與訂閱

4. **運行時層**：提供執行環境
   - 策略隔離沙箱
   - 資源管理和監控

整體架構基於消息驅動和非同步處理，以充分利用現代硬體的多核性能和分佈式特性。

### 2.2 核心技術選型

1. **程式語言和運行時**
   - Rust 作為主要開發語言
   - Tokio 作為非同步運行時框架

2. **消息中間件**
   - RabbitMQ 作為主要消息代理
   - Lapin 作為 Rust RabbitMQ 客戶端
   - Deadpool-Lapin 用於連接池管理

3. **資料庫和儲存**
   - TimescaleDB (PostgreSQL 擴展) 作為主要資料庫
   - Redis 用於快取和輔助存儲
   - Sqlx 作為資料庫驅動

4. **序列化和資料格式**
   - Serde 用於序列化/反序列化
   - YAML, JSON, CSV 支援

5. **數值計算和統計**
   - ndarray 用於多維數組計算
   - polars 用於高效能數據分析和時間序列處理
   - statrs 用於統計運算
   - rust_decimal 用於高精度金融計算

6. **系統工具**
   - parking_lot 用於高效同步原語
   - rayon 用於資料並行處理
   - tracing 用於日誌和診斷

### 2.3 模組化設計

BacktestServer 採用高度模組化的設計，主要模組包括：

1. **領域類型模組 (domain_types)**：定義核心領域類型和資料結構
2. **數據導入模組 (data_ingestion)**：處理外部數據導入和驗證
3. **數據提供模組 (data_provider)**：提供統一的數據訪問介面
4. **策略DSL模組 (dsl)**：解析和執行策略語言
5. **事件處理系統 (event)**：處理系統內部事件通信
6. **隔離運行時模組 (runtime)**：提供策略執行的安全環境
7. **執行模擬器模組 (execution)**：模擬訂單執行和管理倉位
8. **風險管理模組 (risk)**：控制交易風險
9. **消息系統模組 (messaging)**：處理 RabbitMQ 通訊和協議
10. **配置管理模組 (config)**：管理系統配置
11. **伺服器模組 (server)**：管理服務生命週期
12. **回測模組 (backtest)**：協調整個回測流程
13. **存儲系統模組 (storage)**：管理資料儲存

各模組之間通過明確定義的接口和事件系統進行溝通，降低耦合度。

### 2.4 資料流程

回測系統的核心資料流程如下：

1. **歷史資料流**
   - 外部數據來源 → 數據導入模組 → 數據驗證 → 存儲系統 → 資料庫
   - 資料庫 → 數據提供模組 → 資料快取 → 回測引擎

2. **策略執行流**
   - 策略檔案 → DSL解析器 → 策略編譯 → 沙箱運行時
   - 沙箱運行時 ← 市場數據 ← 數據提供模組
   - 沙箱運行時 → 交易信號 → 風險檢查 → 執行模擬器

3. **結果處理流**
   - 執行模擬器 → 交易記錄 → 回測結果處理 → 績效計算 → 資料庫
   - 資料庫 → 消息發布 → RabbitMQ → 外部系統

4. **消息處理流**
   - 外部系統 → RabbitMQ → 消息處理器 → 業務模組 → 處理結果
   - 業務模組 → 事件發布 → RabbitMQ → 外部訂閱系統

### 2.5 時間處理

1. **明確區分不同層級的時間表示**
   - 資料庫層 | TIMESTAMPTZ | 所有資料庫持久化領域
   - 模型層 | DateTime<Utc> | 實體模型、業務邏輯、API 接口
   - 計算核心層 | i64 | 內部時間序列計算、Polars 處理

## 3. 開發規劃

### 3.1 開發階段

專案開發分為六個主要階段：

1. **階段一：專案設置和基礎架構** (1-2週)
   - 專案初始化和環境設定
   - 核心領域類型和基礎設施建立
   - 資料庫基本結構實現
   - RabbitMQ 環境設置

2. **階段二：核心數據功能** (2-3週)
   - 資料導入和驗證功能
   - 資料提供和快取邏輯
   - 配置管理系統
   - RabbitMQ 連接和基本功能

3. **階段三：回測與執行模組** (3-4週)
   - 執行模擬器實現
   - 風險管理模組
   - 回測引擎和事件系統
   - 消息協議設計

4. **階段四：策略與隔離運行時** (3-4週)
   - 策略DSL解析器和運行時
   - 隔離沙箱環境
   - 策略生命週期管理
   - 消息處理器開發

5. **階段五：消息系統集成** (2-3週)
   - 消息模型和處理器實現
   - 消息認證和授權系統
   - 伺服器配置和啟動
   - 事件發布整合

6. **階段六：集成與測試** (3-4週)
   - 自動化測試和效能測試
   - 文檔和示例完善
   - 部署和CI/CD流程
   - 客戶端示例開發

### 3.2 里程碑

1. **里程碑 1：最小可行產品 (MVP)**
   - 完成核心回測功能
   - 基本策略DSL支援
   - 簡單 RabbitMQ 消息接口
   - 預計時間：第三階段結束後

2. **里程碑 2：Alpha 版本**
   - 完整的策略運行時
   - 完善的消息處理系統
   - 基本的消息認證
   - 預計時間：第五階段結束後

3. **里程碑 3：Beta 版本**
   - 完整的測試覆蓋
   - 優化的效能
   - 完善的文檔和示例
   - 預計時間：第六階段結束後

4. **里程碑 4：正式版本 1.0**
   - 生產環境部署
   - 穩定的消息協議和性能
   - 完整的監控和日誌系統
   - 預計時間：Beta版本後4週

### 3.3 時程安排

總體開發時間預計為 14-20 週，大致分配如下：

- **第一階段**：週 1-2
- **第二階段**：週 3-5
- **第三階段**：週 6-9
- **第四階段**：週 10-13
- **第五階段**：週 14-16
- **第六階段**：週 17-20

各階段的具體任務和優先級在 TASK.md 中有詳細說明。

### 3.4 團隊分工

依據專案規模和功能劃分，建議的團隊組成：

1. **核心開發者**：負責整體架構和核心模組實現
   - 回測引擎和執行模擬
   - 策略DSL和運行時
   - 資料模型和領域類型

2. **資料專家**：負責數據相關功能
   - 資料導入和清洗
   - 資料庫優化
   - 技術指標計算

3. **消息系統開發者**：負責通訊功能
   - RabbitMQ 整合
   - 消息協議設計
   - 事件處理和路由
   - 認證與授權

4. **測試和DevOps**：負責質量保證和部署
   - 自動化測試
   - 效能測試
   - CI/CD和部署

根據專案規模，這些角色可能由同一人承擔多個責任。

## 4. 核心模組詳細規劃

### 4.1 領域類型模組

領域類型模組定義了整個系統中使用的核心金融數據結構、枚舉和類型。

**主要組件**:
- `asset_types.rs`: 定義資產類型、數據類型和交易類型
- `data_point.rs`: 使用 Polars Series 定義 OHLCV 和 Tick 數據點結構
- `time_series.rs`: 使用 Polars DataFrame 定義通用時間序列數據結構
- `frequency.rs`: 定義與 Polars 時間索引整合的數據頻率枚舉
- `aggregation.rs`: 基於 Polars 實現數據聚合操作

**優先實施項目**:
- 基於 Polars 的資產類型結構
- 基於 Polars DataFrame 的時間序列數據結構
- 基於 Polars Series 的數據點類型

**技術考量**:
- 使用 Polars 實現高效的數據處理和分析
- 使用 serde 和 rust_decimal 確保序列化和精確財務計算
- 使用 chrono 與 Polars 時間索引整合
- 使用枚舉和強類型確保類型安全

### 4.2 數據處理模組

包含數據導入模組和數據提供模組，負責數據的導入、驗證、提供和轉換。

**主要組件**:
- **數據導入子模組**:
  - `processor.rs`: 數據導入處理流程
  - `csv_io.rs`: CSV 文件讀取
  - `validator.rs`: 數據驗證流程

- **數據提供子模組**:
  - `loader.rs`: 統一數據加載器
  - `resampler.rs`: 使用 Polars 實現時間序列重採樣
  - `iterator.rs`: 市場數據迭代器
  - `cache.rs`: 數據緩存管理

**優先實施項目**:
- CSV 讀取功能
- 基本數據驗證
- 統一數據加載器
- 時間序列重採樣

**技術考量**:
- 使用非同步 I/O 進行數據處理
- 實現有效的數據緩存策略
- 支援批處理以提高效能
- 充分利用 Polars 提供的高效數據操作和時間序列功能

### 4.3 策略 DSL 模組

策略DSL模組提供專用的領域特定語言，簡化策略開發並確保執行安全。

**主要組件**:
- `parser.rs`: 解析 YAML 策略定義
- `runtime.rs`: 執行策略邏輯
- `stdlib.rs`: 提供標準函數庫
- `compiler.rs`: 編譯優化策略代碼

**優先實施項目**:
- 基本 YAML 解析功能
- 策略運行時環境
- 核心標準庫函數

**技術考量**:
- 使用 serde_yaml_bw 處理 YAML 格式
- 設計安全的執行環境
- 實現高效的指標計算

### 4.4 回測引擎模組

回測引擎模組是系統的核心，負責協調整個回測流程。

**主要組件**:
- `engine.rs`: 回測引擎核心
- `task.rs`: 回測任務管理
- `results.rs`: 回測結果處理
- `context.rs`: 回測執行上下文
- `metrics.rs`: 績效指標計算

**優先實施項目**:
- 回測引擎基本架構
- 任務管理和結果處理
- 執行上下文設計

**技術考量**:
- 使用 Tokio 實現非同步處理
- 實現可靠的任務狀態追蹤
- 設計高效的數據傳遞機制

### 4.5 消息系統模組

消息系統模組實現基於 RabbitMQ 的通訊機制，處理系統間的消息交換。

**主要組件**:
- **RabbitMQ整合**:
  - `connection.rs`: 連接管理和連接池
  - `broker.rs`: 消息代理和路由
  - `client.rs`: 客戶端API
  - `rpc.rs`: 請求-回應模式

- **消息協議**:
  - `protocol.rs`: 通訊協議定義
  - `models/commands.rs`: 命令消息模型
  - `models/events.rs`: 事件消息模型
  - `models/responses.rs`: 回應消息模型

- **消息處理**:
  - `handlers/backtest.rs`: 回測消息處理
  - `handlers/strategy.rs`: 策略消息處理
  - `handlers/data.rs`: 數據消息處理

**優先實施項目**:
- RabbitMQ連接管理
- 消息協議定義
- 基本消息處理器
- 客戶端API

**技術考量**:
- 使用 lapin 與 RabbitMQ 通訊
- 使用 deadpool-lapin 管理連接池
- 實現可靠的錯誤處理和重試機制
- 設計高效的消息序列化格式

## 5. 資料庫設計

### 5.1 資料庫技術選型

BacktestServer 使用 TimescaleDB 作為主要資料庫，這是 PostgreSQL 的時間序列擴展，特別適合金融數據管理：

**優勢**:
- 高效時間序列查詢
- 與 PostgreSQL 兼容的功能和生態系統
- 強大的資料壓縮和分區功能
- 支援連續聚合（continuous aggregates）

**Redis 作為輔助儲存**:
- 用於高效能快取
- 支援發布/訂閱事件模式
- 實現分散式鎖和任務佇列

### 5.2 主要資料表結構

資料庫結構分為幾個主要類別：

1. **基礎資產表**
   - `exchange`: 交易所信息
   - `instrument`: 金融商品基本信息

2. **市場數據表**
   - `minute_bar`: 分鐘級 K 線數據（超表）
   - `tick`: Tick 級行情數據（超表）

3. **策略和交易表**
   - `strategy`: 策略定義
   - `strategy_version`: 策略版本管理

4. **回測相關表**
   - `backtest_config`: 回測設定
   - `backtest_result`: 回測結果摘要
   - `backtest_trade`: 回測交易記錄（超表）
   - `backtest_position_snapshot`: 回測倉位快照（超表）
   - `backtest_portfolio_snapshot`: 回測投資組合快照（超表）

5. **技術指標表**
   - `technical_indicator`: 指標定義
   - `instrument_daily_indicator`: 預計算指標數據（超表）

### 5.3 查詢優化策略

為確保系統性能，採用以下優化策略：

1. **資料分區 (Chunking)**
   - 按時間將資料分區存儲
   - 使用 TimescaleDB 的自動分區功能

2. **資料壓縮**
   - 對較舊資料進行自動壓縮
   - 設定合理的壓縮政策

3. **連續聚合**
   - 預先計算常用聚合查詢
   - 如 `daily_volume_by_instrument`
   - 如 `backtest_daily_returns`

4. **索引策略**
   - 針對常用查詢路徑建立專用索引
   - 使用複合索引優化多條件查詢

5. **查詢優化**
   - 使用參數化查詢
   - 優化 JOIN 和子查詢

## 6. 測試策略

### 6.1 測試類型

BacktestServer 採用多層次測試策略：

1. **單元測試**
   - 位於各模組中的 `tests` 子模組
   - 測試單個功能和組件
   - 使用 Rust 內建的測試框架

2. **集成測試**
   - 位於 `tests/` 目錄
   - 測試多個組件的協同工作
   - 主要注重模組間的互動

3. **性能測試**
   - 位於 `benches/` 目錄
   - 測量關鍵操作的效能
   - 使用 Criterion.rs 框架

4. **消息系統測試**
   - 測試 RabbitMQ 消息通訊
   - 測試消息處理流程
   - 使用專用測試容器和模擬組件

### 6.2 測試自動化

使用以下工具和策略實現測試自動化：

1. **測試工具**
   - `cargo test` 執行標準測試
   - `cargo-nextest` 執行優化測試
   - `mockall` 用於模擬依賴組件
   - `proptest` 用於基於屬性的測試

2. **CI/CD 整合**
   - GitHub Actions 自動執行測試
   - 每次提交和合併請求時運行測試
   - 定期執行完整測試套件

3. **測試覆蓋率**
   - 追蹤代碼覆蓋率
   - 重點關注核心功能覆蓋

### 6.3 效能測試

效能測試專注於以下關鍵領域：

1. **數據處理效能**
   - 大數據量導入測試
   - 資料查詢和過濾效能

2. **策略執行效能**
   - 策略解析和編譯速度
   - 執行迴圈性能

3. **回測引擎基準測試**
   - 多策略並行執行能力
   - 長時間序列回測性能

4. **消息系統效能**
   - 消息傳遞延遲
   - 高負載下吞吐量
   - 並發消息處理能力

## 7. 部署與運維

### 7.1 部署環境

BacktestServer 支援以下部署方式：

1. **Docker 容器化**
   - 主要應用容器
   - TimescaleDB 容器
   - Redis 容器
   - RabbitMQ 容器
   - 使用 docker-compose 協調

2. **可選部署環境**
   - 開發環境
   - 測試/QA 環境
   - 生產環境

3. **資源需求**
   - CPU: 至少 4 核心（生產環境建議 8+）
   - 記憶體: 至少 8GB（生產環境建議 16GB+）
   - 儲存: SSD，容量視數據量而定

### 7.2 監控策略

實施以下監控機制：

1. **系統監控**
   - 使用 `metrics` 和 `metrics-exporter-prometheus` 收集指標
   - 追蹤系統資源使用率
   - 監控消息佇列長度和延遲

2. **日誌管理**
   - 使用 `tracing` 實現結構化日誌
   - 設定不同等級的日誌輸出
   - 集中式日誌收集

3. **警報機制**
   - 設定關鍵指標閾值警報
   - RabbitMQ 服務狀態監控
   - 緊急事件通知管道

### 7.3 備份與恢復

資料保護策略：

1. **資料庫備份**
   - TimescaleDB 定期自動備份
   - 事務日誌儲存

2. **策略備份**
   - 策略檔案版本控制
   - 定期匯出策略定義

3. **RabbitMQ 配置備份**
   - 交換機和佇列定義備份
   - 消息持久化策略

4. **恢復計劃**
   - 定義明確的恢復步驟
   - 定期測試恢復流程

## 8. 風險評估與管理

### 8.1 技術風險

1. **效能風險**
   - 識別潛在瓶頸，如數據加載和處理
   - 消息系統高負載情況處理
   - 及早進行效能測試
   - 實施效能優化策略

2. **安全風險**
   - 策略沙箱隔離可能存在漏洞
   - 消息系統認證和授權機制缺陷
   - 定期安全審核和更新

3. **可靠性風險**
   - 資料一致性問題
   - 消息丟失或重複處理
   - 系統崩潰恢復能力
   - 壓力測試和故障模擬

### 8.2 專案風險

1. **時程風險**
   - 複雜模組可能需要更長開發時間
   - 消息系統整合的複雜性
   - 採用迭代開發和優先級分配
   - 定期評估進度和調整計劃

2. **整合風險**
   - 模組間協作出現問題
   - 早期整合測試
   - 明確定義消息協議

3. **需求變更風險**
   - 功能需求可能隨時間變化
   - 採用敏捷開發方法適應變更
   - 保持架構彈性

## 9. 擴展性考量

### 9.1 未來功能擴展

規劃中的潛在擴展：

1. **資料來源擴展**
   - 增加更多資料提供商和來源
   - 支援更多資料格式

2. **策略功能增強**
   - 支援更複雜的策略語法
   - 加入機器學習整合

3. **即時回測**
   - 支援邊緣數據回測
   - 策略優化參數掃描

4. **分佈式處理**
   - 使用 RabbitMQ 實現分散式回測
   - 工作任務分配和結果聚合

### 9.2 架構擴展性

為確保長期擴展性，系統設計考慮：

1. **模組化設計**
   - 保持模組間低耦合
   - 使用定義良好的消息接口

2. **可插拔組件**
   - 支援策略插件系統
   - 資料源和指標計算器可擴展
   - 消息處理器可動態註冊

3. **水平擴展**
   - 支援分散式回測執行
   - 通過 RabbitMQ 實現負載平衡

4. **消息協議版本控制**
   - 實施消息協議版本管理
   - 確保向後兼容性