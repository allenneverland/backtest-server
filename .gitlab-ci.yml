# GitLab CI/CD 配置檔案
# 用於自動化構建、測試和部署 BacktestServer 專案

# 使用與開發環境相同的 Rust 版本
image: rust:1.87-slim-bullseye

# 工作流程規則 - 避免重複的 pipeline
workflow:
  rules:
    # 如果是 merge request，創建 pipeline
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # 如果是推送到主分支，創建 pipeline
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    # 如果是推送到分支且沒有開啟的 MR，創建 pipeline
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    # 其他分支推送，創建 pipeline
    - if: $CI_COMMIT_BRANCH

# 定義 CI/CD 階段
stages:
  - prepare
  - build
  - test
  - quality
  - coverage
  - deploy

# 預設 before_script
default:
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install cargo-make --version 0.37.24 || cargo install cargo-make
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"

# 全域變數設定
variables:
  # 資料庫連接設定
  DB_HOST: "postgres"
  DB_PORT: "5432"
  DB_USER: "backtest"
  DB_PASSWORD: "backtest123"
  DB_NAME: "backtest_db"
  DATABASE_URL: "postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}"
  
  # Redis 連接設定
  REDIS_HOST: "redis"
  REDIS_PORT: "6379"
  REDIS_URL: "redis://${REDIS_HOST}:${REDIS_PORT}"
  
  # RabbitMQ 連接設定
  RABBITMQ_HOST: "rabbitmq"
  RABBITMQ_PORT: "5672"
  RABBITMQ_USER: "guest"
  RABBITMQ_PASSWORD: "guest"
  RABBITMQ_URL: "amqp://${RABBITMQ_USER}:${RABBITMQ_PASSWORD}@${RABBITMQ_HOST}:${RABBITMQ_PORT}"
  
  # Rust 相關設定
  CARGO_HOME: ${CI_PROJECT_DIR}/.cargo
  RUST_BACKTRACE: "1"
  RUSTFLAGS: "-C target-cpu=native"
  
  # GitLab CI 優化
  FF_USE_FASTZIP: "true"
  ARTIFACT_COMPRESSION_LEVEL: "fast"

# 服務依賴
services:
  # TimescaleDB
  - name: timescale/timescaledb:latest-pg14
    alias: postgres
    variables:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
  
  # Redis
  - name: redis:7-alpine
    alias: redis
    command: ["redis-server", "--save", "60", "1", "--loglevel", "warning"]
  
  # RabbitMQ
  - name: rabbitmq:3.11-management
    alias: rabbitmq
    variables:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}

# 快取設定
.cache_config: &cache_config
  cache:
    key:
      files:
        - Cargo.lock
        - Cargo.toml
    paths:
      - ${CARGO_HOME}
      - target/

# 準備階段：驗證環境
prepare:verify:
  stage: prepare
  <<: *cache_config
  script:
    - cargo --version
    - rustc --version
    - rustup --version
  artifacts:
    expire_in: 1 hour

# 構建階段：檢查和編譯
build:check:
  stage: build
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install sqlx-cli --no-default-features --features postgres --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
    # 等待資料庫服務啟動
    - |
      until pg_isready -h postgres -p 5432 -U ${DB_USER}; do
        echo "Waiting for database..."
        sleep 2
      done
    # 執行資料庫遷移
    - sqlx database create || true
    - sqlx migrate run --source migrations
  script:
    - cargo check --all-targets
  allow_failure: false

build:debug:
  stage: build
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install sqlx-cli --no-default-features --features postgres --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
    # 等待資料庫服務啟動
    - |
      until pg_isready -h postgres -p 5432 -U ${DB_USER}; do
        echo "Waiting for database..."
        sleep 2
      done
    # 執行資料庫遷移
    - sqlx database create || true
    - sqlx migrate run --source migrations
  script:
    - cargo build
  artifacts:
    paths:
      - target/debug/
    expire_in: 1 hour

build:release:
  stage: build
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install sqlx-cli --no-default-features --features postgres --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
    # 等待資料庫服務啟動
    - |
      until pg_isready -h postgres -p 5432 -U ${DB_USER}; do
        echo "Waiting for database..."
        sleep 2
      done
    # 執行資料庫遷移
    - sqlx database create || true
    - sqlx migrate run --source migrations
  script:
    - cargo build --release
  artifacts:
    paths:
      - target/release/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# 測試階段：運行各種測試
test:unit:
  stage: test
  <<: *cache_config
  needs:
    - job: build:check
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install sqlx-cli --no-default-features --features postgres --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
    # 等待資料庫服務啟動
    - |
      until pg_isready -h postgres -p 5432 -U ${DB_USER}; do
        echo "Waiting for database..."
        sleep 2
      done
    # 執行資料庫遷移
    - sqlx database create || true
    - sqlx migrate run --source migrations
  script:
    - cargo test --lib --bins
  coverage: '/^\d+.\d+% coverage/'
  artifacts:
    reports:
      junit: target/junit.xml
    expire_in: 1 week

test:integration:
  stage: test
  <<: *cache_config
  needs:
    - job: build:check
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add rustfmt clippy || true
    - cargo install sqlx-cli --no-default-features --features postgres --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
    # 等待資料庫服務啟動
    - |
      until pg_isready -h postgres -p 5432 -U ${DB_USER}; do
        echo "Waiting for database..."
        sleep 2
      done
    # 執行資料庫遷移
    - sqlx database create || true
    - sqlx migrate run --source migrations
  script:
    - cargo test --test '*'
  artifacts:
    reports:
      junit: target/junit-integration.xml
    expire_in: 1 week
  allow_failure: true

# 品質檢查階段
quality:format:
  stage: quality
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  script:
    - cargo fmt -- --check
  allow_failure: false

quality:lint:
  stage: quality
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  script:
    - cargo clippy -- -D warnings
  allow_failure: false

# 測試覆蓋率階段
coverage:report:
  stage: coverage
  <<: *cache_config
  needs:
    - job: test:unit
      optional: true
    - job: test:integration
      optional: true
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq git pkg-config libssl-dev libpq-dev postgresql-client make cmake g++
    - rustup component add llvm-tools-preview
    - cargo install cargo-llvm-cov --locked || true
    # 將 cargo bin 目錄加入 PATH
    - export PATH="${CARGO_HOME}/bin:${PATH}"
  script:
    - cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info || cargo test
    - cargo llvm-cov report || true
  coverage: '/Total coverage: (\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - target/llvm-cov/html/
    expire_in: 1 week

# 部署階段（示例）
deploy:staging:
  stage: deploy
  needs:
    - job: build:release
      optional: true
    - job: test:unit
      optional: true
    - job: test:integration
      optional: true
    - job: quality:format
      optional: true
    - job: quality:lint
      optional: true
  script:
    - echo "部署到測試環境..."
    # 在此添加實際的部署腳本
  environment:
    name: staging
    url: https://staging.backtest-server.example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual

deploy:production:
  stage: deploy
  needs:
    - job: build:release
      optional: true
    - job: test:unit
      optional: true
    - job: test:integration
      optional: true
    - job: quality:format
      optional: true
    - job: quality:lint
      optional: true
    - job: coverage:report
      optional: true
  script:
    - echo "部署到生產環境..."
    # 在此添加實際的部署腳本
  environment:
    name: production
    url: https://backtest-server.example.com
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  allow_failure: false

# 通知設定（可選）
.notify_template: &notify_template
  after_script:
    - |
      if [ "$CI_JOB_STATUS" == "failed" ]; then
        echo "Job failed: $CI_JOB_NAME"
        # 在此添加通知邏輯（如 Slack、Email 等）
      fi

# 安全掃描（可選）
security:dependency-check:
  stage: quality
  <<: *cache_config
  needs:
    - job: prepare:verify
      optional: true
  script:
    - cargo install cargo-audit --locked || true
    - cargo audit || echo "Security audit completed with warnings"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"